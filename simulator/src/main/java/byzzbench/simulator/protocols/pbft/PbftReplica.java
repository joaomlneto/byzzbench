package byzzbench.simulator.protocols.pbft;

import byzzbench.simulator.LeaderBasedProtocolReplica;
import byzzbench.simulator.Timekeeper;
import byzzbench.simulator.Timer;
import byzzbench.simulator.protocols.pbft.message.*;
import byzzbench.simulator.state.TotalOrderCommitLog;
import byzzbench.simulator.transport.MessagePayload;
import byzzbench.simulator.transport.Transport;
import lombok.Getter;
import lombok.extern.java.Log;

import java.io.Serializable;
import java.time.Duration;
import java.time.Instant;
import java.util.*;
import java.util.function.Function;
import java.util.logging.Level;

/**
 * A replica implementing the Practical Byzantine Fault Tolerance (PBFT) protocol,
 * based on the latest version of the protocol as published in the web page of the
 * authors of the protocol.
 */
@Log
public class PbftReplica extends LeaderBasedProtocolReplica {
    private static final Duration AUTHENTICATION_TIMEOUT = Duration.ofSeconds(1);
    /**
     * JC: This controls batching, and is the maximum number of messages that can be outstanding
     * at any one time. i.e. with CW=1, can't send a pp unless a previous operation has executed.
     */
    private static final int congestion_window = 1;
    /**
     * Configuration for the PBFT protocol. FIXME: Should be configurable!
     */
    @Getter
    private final PbftProtocolConfiguration config = new PbftProtocolConfiguration();
    /**
     * View-info abstraction manages information about view changes
     */
    private final ViewInfo vi;
    /**
     * Sets and logs to keep track of <b>read-write</b> requests received. Their size is equal to max_out.
     */
    private final ReqQueue rqueue = new ReqQueue(this);
    /**
     * Sets and logs to keep track of <b>read-only</b> requests received. Their size is equal to max_out.
     */
    private final ReqQueue ro_rqueue = new ReqQueue(this);
    /**
     * List of prepared certificates?
     */
    private final SeqNumLog<PreparedCertificate> plog;
    /**
     * The big request table
     */
    private final BigReqTable brt = new BigReqTable(this);
    /**
     * List of committed certificates?
     */
    private final SeqNumLog<Certificate<CommitMessage>> clog;
    /**
     * List of pre-prepared certificates?
     */
    private final SeqNumLog<Certificate<CheckpointMessage>> elog;
    /**
     * Set of stable checkpoint messages above my window.
     */
    private final IdentifiableObjectsSet<CheckpointMessage> sset;
    /**
     * Last replies sent to each principal
     */
    private final RepInfo replies = new RepInfo();
    /**
     * State abstraction manages state checkpointing and digesting
     */
    private final State state = new State(this);
    /**
     * True iff replica's last_stable is sufficient to start processing requests in new view.
     */
    private final boolean has_nv_state;
    /**
     * View change timer
     * TODO: Should be an "ITimer" in ByzzBench!
     */
    private final Timer vtimer;
    /**
     * Timer to send status messages periodically
     * FIXME: Change into an "ITimer" in ByzzBench!
     */
    private final Timer stimer;
    /**
     * Recovery timer. TODO: Timeout should be generated by watchdog.
     * FIXME: Change into an "ITimer" in ByzzBench!
     */
    private final Timer rtimer;
    /**
     * Views in recovery replies.
     */
    private final Map<String, Long> rr_views;
    /**
     * Timer to trigger transmission of null requests when system is idle
     */
    private final Timer ntimer;
    /**
     * FIXME: Undocumented
     */
    private final Runnable exec_command;
    /**
     * Authentication timer. FIXME: Should be an "ITimer" in ByzzBench!
     */
    private final Timer atimer;
    /**
     * Map from principal identifiers to Principal.
     */
    protected SortedMap<String, Principal> principals = new TreeMap<>();
    /**
     * Seqno_max if not known
     */
    long recovery_point;
    /**
     * Maximum sequence number of a recovery request in state.
     */
    long max_rec_n;
    /**
     * Sequence number of last stable state.
     */
    private long last_stable;
    /**
     * Low bound on request sequence numbers that may be accepted in current view.
     */
    private long low_bound;
    /**
     * True iff replica is recovering
     */
    private boolean recovering;
    /**
     * Outstanding recovery request or null if there is no outstanding recovery request.
     */
    private RequestMessage rr;
    /**
     * Message sent for estimation; qs != null iff replica is estimating
     * the maximum stable checkpoint.
     */
    private QueryStableMessage qs;
    /**
     * Time when last status message was sent
     */
    private Instant last_status;
    /**
     * True iff moved to new view but did not start vtimer yet.
     */
    private boolean limbo;
    /**
     * ID of primary for the current view
     */
    private String cur_primary;
    /**
     * Last view known to this node
     */
    private long v;
    /**
     * Sequence number of last executed message
     */
    private long last_executed;
    /**
     * Sequence number of last message tentatively executed
     */
    private long last_tentative_execute;
    /**
     * Sequence number of highest prepared request
     */
    private long last_prepared;
    /**
     * Sequence number to attribute to next protocol message. Only valid if I am the primary.
     */
    private long seqno;
    /**
     * The number of rounds of BFT executed in current interval
     */
    private int nbrounds;
    /**
     * The number of requests executed in current interval
     */
    private int nbreqs;
    /**
     * True iff replica is ready to recover.
     */
    private boolean rec_ready;
    /**
     * FIXME: Undocumented
     */
    private Runnable non_det_choices;
    /**
     * Certificate with replies to a recovery request.
     */
    private Certificate<ReplyMessage> rr_reps;
    /**
     * FIXME: Undocumented
     */
    private int max_nondet_choice_len;
    /**
     * FIXME: Undocumented, Only available in BASE
     */
    private int n_mem_blocks;
    /**
     * True iff replica exited limbo for a view after it started recovery
     */
    private boolean vc_recovering;
    /**
     * True if replica's data was found to be corrupt.
     */
    private boolean corrupt;
    /**
     * Estimation of the maximum stable checkpoint at any non-faulty replica
     */
    private StableEstimator se;
    /**
     * Special principal associated with the group of replicas
     */
    private Principal group;
    /**
     * Last new-key message we sent
     */
    private NewKeyMessage last_new_key;
    /**
     * State for unique identifier generator.
     * FIXME: Change into an AtomicLong
     */
    private long cur_rid;
    /**
     * the check_non_det function
     */
    private Function<ByzBuffer, Boolean> check_non_det;

    public PbftReplica(String nodeId, SortedSet<String> nodeIds, Transport transport, Timekeeper timekeeper) {
        super(nodeId, nodeIds, transport, timekeeper, new TotalOrderCommitLog());

        /**
         * Node.cc constructor below
         */
        // Initialize random number generator
        //random_init(); // should be done automatically by ByzzBench

        // TODO: Private key and public key should be provided by ByzzBench
        // Read-config-file and Networking stuff skippedâ€¦

        // Initialize current view number and primary
        this.v = 0;
        this.cur_primary = getPrimaryForView(this.v);

        // ...

        // Compute new timestamp for cur_rid
        new_tstamp();

        last_new_key = null;

        atimer = new Timer(this, "Authentication Timeout", AUTHENTICATION_TIMEOUT, () -> {
            throw new UnsupportedOperationException("Authentication timeout not implemented");
        });

        /**
         * Replica.cc constructor below
         */

        // TODO: set config_file
        // TODO: set config_priv
        // TODO: set port -- not required in byzzbench!

        this.plog = new SeqNumLog<>(config.getMAX_OUT());
        this.clog = new SeqNumLog<>(config.getMAX_OUT());
        this.elog = new SeqNumLog<>(config.getMAX_OUT() * 2);
        this.sset = new IdentifiableObjectsSet<>(nodeIds);

        // TODO: replies should have a size of num_principals in BASE, (mem, num_principals) in BFT

        // TODO: state!

        this.vi = new ViewInfo(nodeId, 0);
        // TODO: this.n_mem_blocks = num_objs; // constructor argument; BASE-only

        this.seqno = 0;
        this.last_stable = 0;
        this.low_bound = 0;

        this.last_prepared = 0;
        this.last_executed = 0;
        this.last_tentative_execute = 0;

        this.last_status = null;

        this.limbo = false;
        this.has_nv_state = true;

        this.nbreqs = 0;
        this.nbrounds = 0;

        // TODO: read view change, status, and recovery timeouts from replica's portion of "config_file".
        /*
          int vt, st, rt;
          fscanf(config_file, "%d\n", &vt);
          fscanf(config_file, "%d\n", &st);
          fscanf(config_file, "%d\n", &rt);
         */

        // TODO: Create timers and randomize times to avoid collisions.
        // srand48(getpid());
        this.vtimer = null; // FIXME
        this.stimer = null; // FIXME

        // Skew recoveries. It is important for nodes to recover in the reverse order
        // of their node ids to avoid a view-change every recovery which would degrade
        // their performance.
        this.rtimer = null; // FIXME
        this.rec_ready = false;
        //this.rtimer.start() // FIXME

        this.ntimer = null; // FIXME

        this.recovering = false;
        this.qs = null;
        this.rr = null;
        this.rr_views = new HashMap<>(); // TODO: Set size to num_replicas
        this.recovery_point = Long.MAX_VALUE;
        this.max_rec_n = 0;

        this.exec_command = null;
        this.non_det_choices = null;

        join_mcast_group();

        nodeIds.stream()
                // filter out the current node
                .filter(nodeId::equals)
                // create a principal for every other node
                .forEach(otherNodeId ->
                        principals.put(otherNodeId, new Principal(otherNodeId, ""))
                );

        this.initialize();
    }

    @Override
    public void initialize() {
        // TODO: Timers (Replica.cc, lines 135-147)
        this.recv();
    }

    /**
     * Initialize replica before receiving messages
     */
    private void recv() {
        // Compute session keys and send initial new-key message.
        this.send_new_key();

        // Compute digest of initial state and first checkpoint.
        this.state.compute_full_digest();

        // Start status and authentication freshness timers
        this.stimer.start();
        this.atimer.start();
        if (id().equals(primary())) {
            // Start view change timer
            this.ntimer.start();
        }

        this.rec_ready = true;

        log.info("Replica initialized");
    }

    /**
     * Returns the identifier of the primary for current view
     *
     * @return The ID of the primary for the current view
     */
    public String primary() {
        return cur_primary;
    }

    /**
     * Returns the identifier of the primary for view v.
     *
     * @param vi The view information
     * @return The ID of the primary for the given view
     */
    public String primary(long vi) {
        String[] replicaIds = this.getNodeIds().toArray(String[]::new);
        return (vi == v) ? this.cur_primary : replicaIds[(int) (vi % replicaIds.length)];
    }

    @Override
    public void handleClientRequest(String clientId, Serializable request) throws Exception {
        if (request instanceof RequestMessage) {
            this.handleMessage(clientId, (RequestMessage) request);
        } else {
            throw new UnsupportedOperationException("Unknown request type: " + request.getClass().getName());
        }
    }

    @Override
    public void handleMessage(String sender, MessagePayload message) throws Exception {
        // for some reason the original code does this before receiving a message.
        // not sure why, but it's here now. might remove it later.
        if (this.state.in_check_state()) {
            this.state.check_state();
        }

        // while estimating, replica only handles certain messages.
        if (this.qs != null && !(message instanceof NewKeyMessage) &&
                !(message instanceof QueryStableMessage) &&
                !(message instanceof ReplyStableMessage) &&
                !(message instanceof StatusMessage)
        ) {
            // discard message
            return;
        }

        // while recovering, replica only handles certain messages.
        if (state.in_check_state() && (message instanceof RequestMessage
                || message instanceof PrePrepareMessage
                || message instanceof PrepareMessage
                || message instanceof CommitMessage)
        ) {
            // discard message
            return;
        }


        if (message instanceof RequestMessage requestMessage) {
            this.handleRequest(requestMessage);
        } else if (message instanceof PrePrepareMessage prePrepareMessage) {
            this.handlePrePrepare(prePrepareMessage);
        } else if (message instanceof PrepareMessage prepareMessage) {
            this.handlePrepare(prepareMessage);
        } else if (message instanceof CommitMessage commitMessage) {
            this.handleCommit(commitMessage);
        } else if (message instanceof CheckpointMessage checkpointMessage) {
            this.handleCheckpoint(checkpointMessage);
        } else if (message instanceof ViewChangeMessage viewChangeMessage) {
            this.handleViewChange(viewChangeMessage);
        } else if (message instanceof NewViewMessage newViewMessage) {
            this.handleNewView(newViewMessage);
        } else if (message instanceof ViewChangeAcknowledgementMessage viewChangeAcknowledgementMessage) {
            this.handleViewChangeAck(viewChangeAcknowledgementMessage);
        } else if (message instanceof StatusMessage statusMessage) {
            this.handleStatus(statusMessage);
        } else if (message instanceof NewKeyMessage newKeyMessage) {
            this.handleNewKey(newKeyMessage);
        } else if (message instanceof FetchMessage fetchMessage) {
            this.handleFetch(fetchMessage);
        } else if (message instanceof DataMessage dataMessage) {
            this.handleData(dataMessage);
        } else if (message instanceof MetadataMessage metadataMessage) {
            this.handleMetadata(metadataMessage);
        } else if (message instanceof MetadataDigestMessage metadataDigestMessage) {
            this.handleMetadataD(metadataDigestMessage);
        } else if (message instanceof ReplyMessage replyMessage) {
            this.handleReply(replyMessage);
        } else if (message instanceof QueryStableMessage queryStableMessage) {
            this.handleQueryStable(queryStableMessage);
        } else if (message instanceof ReplyStableMessage replyStableMessage) {
            this.handleReplyStable(replyStableMessage);
        }

        // Unknown message type
        throw new UnsupportedOperationException("Unknown message type: " + message.getClass().getName());
    }

    public boolean hasNewView() {
        return v == 0 || (has_nv_state && vi.hasNewView(v));
    }

    /**
     * Returns the principal with the given ID.
     *
     * @param id The ID of the principal.
     * @return The principal with the given ID.
     */
    public Principal getPrincipal(String id) {
        if (!principals.containsKey(id)) {
            principals.put(id, new Principal(id, id));
        }
        return principals.get(id);
    }

    /**
     * Returns this replica's principal.
     *
     * @return This replica's principal.
     */
    public Principal getPrincipal() {
        return getPrincipal(id());
    }

    /**
     * Checks whether the given ID is that of a replica.
     *
     * @param id The ID to check.
     * @return True if the ID is that of a replica, false otherwise.
     */
    public boolean isReplica(String id) {
        return this.getNodeIds().contains(id);
    }

    /**
     * Execute the protocol steps associated with the arrival of a {@link RequestMessage}.
     *
     * @param m The RequestMessage from the client.
     */
    private void handleRequest(RequestMessage m) {
        String cid = m.getCid();
        boolean ro = m.isReadOnly();
        long rid = m.getRid();

        if (has_new_view() && m.verify(this)) {
            // Replica's requests must be signed and cannot be read-only
            if (!is_replica(cid) || (m.isSigned() && ro)) {
                if (ro) {
                    // read-only requests
                    if (execute_read_only(m) || !ro_rqueue.append(m)) {
                        // execute "delete m"; but we're garbage collecting in Java!
                        return;
                    }
                    return;
                }

                long last_rid = replies.req_id(cid);
                if (last_rid < rid) {
                    // Request has not been executed
                    if (id().equals(primary())) {
                        if (!rqueue.in_progress(cid, rid, v) && rqueue.append(m)) {
                            send_pre_prepare();
                        }
                    } else {
                        if (m.isBigRequest() && brt.add_request(m)) {
                            return;
                        }

                        if (rqueue.append(m)) {
                            if (!limbo) {
                                this.sendMessage(m, primary());
                                this.vtimer.start();
                            }
                        }
                    }
                } else if (last_rid == rid) {
                    // Retransmit reply.
                    replies.send_reply(cid, view(), id());

                    if (!id().equals(primary()) && !replies.is_committed(cid) && rqueue.append(m)) {
                        vtimer.start();
                    }
                }
            }
        } else {
            if (m.isBigRequest() && !ro) {
                brt.add_request(m, false);
            }
        }

        // delete m; but we're garbage collecting in Java!
    }

    /**
     * Sends a PrePrepare message to the replica group.
     */
    public void send_pre_prepare() {
        if (!primary().equals(id())) {
            throw new IllegalStateException("Non-primary called send_pre_prepare");
        }

        // If rqueue is empty there are no requests for which to send pre_prepare and
        // a pre-prepare cannot be sent if the seqno excedes the maximum window or the
        // replica does not have the new view
        if (rqueue.size() > 0
                && seqno + 1 <= last_executed + congestion_window
                && seqno + 1 <= config.getMAX_OUT() + last_stable && has_new_view()) {
            // System.out.printf("rqueue.size = %d\n%n", rqueue.size());
            // if (seqno % checkpoint_interval == 0)
            // System.out.printf("SND: PRE-PREPARE seqno=%qd last_stable=%qd\n", seqno+1, last_stable);

            this.nbreqs += rqueue.size();
            this.nbrounds++;

            /*
            if (nbreqs >= 10000) {
                System.out.printf("Avg batch sz: %f\n", (float)nbreqs/(float)nbrounds);
                nbreqs = nbrounds = 0;
            } //*/

            // Create new pre_prepare message for set of requests in rqueue,
            // log message and multicast the pre_prepare.
            this.seqno++;
            // System.out.printf("Sending PP seqno %qd\n", seqno);
            PrePrepareMessage pp = new PrePrepareMessage(view(), seqno, rqueue);

            // TODO: should make code match my proof with request removed
            // only when executed rather than removing them from rqueue when the
            // pre-prepare is constructed
            // FIXME: check if also need to include self
            this.broadcastMessageIncludingSelf(pp);
            this.plog.fetch(seqno).add(pp);
        }
    }

    /**
     * Check if the given identifier is that of a valid replica.
     *
     * @param cid The identifier to check.
     * @return True if the identifier is that of a replica, false otherwise.
     */
    public boolean is_replica(String cid) {
        return this.getNodeIds().contains(cid);
    }

    /**
     * Execute the protocol steps associated with the arrival of a {@link PrePrepareMessage}.
     *
     * @param m The PrePrepareMessage.
     */
    private void handlePrePrepare(PrePrepareMessage m) {
        long ms = m.getSeqno();

        ByzBuffer b = new ByzBuffer();
        b.contents = m.choices(b.size);

        if (in_wv(m) && ms > low_bound && has_new_view() && (config.NO_STATE_TRANSLATION() || check_non_det.apply(b))) {
            PreparedCertificate pc = plog.fetch(ms);

            // Only accept message if we never accepted another pre-prepare
            // for the same view and sequence number and the message is valid.
            if (pc.add(m)) {
                send_prepare(pc);
                if (pc.is_complete()) {
                    send_commit(ms);
                }
            }
            return;
        }

        if (!has_new_view()) {
            // This may be an old pre-prepare that replica needs to complete a view-change.
            vi.addMissing(m);
            return;
        }

        throw new UnsupportedOperationException("handlePrePrepare() not implemented");
    }

    /**
     * Execute the protocol steps associated with the arrival of a {@link PrepareMessage}.
     *
     * @param m The PrepareMessage.
     */
    private void handlePrepare(PrepareMessage m) {
        long ms = m.getSeqno();

        // Only accept prepare messages that are not sent by the primary for current view.
        if (in_wv(m) && ms > low_bound && primary() != m.id() && has_new_view()) {
            PreparedCertificate ps = plog.fetch(ms);
            if (ps.add(m) && ps.is_complete()) {
                send_commit(ms);
            }
            return;
        }

        if (m.is_proof() && !has_new_view()) {
            // This may be a prepare sent to prove the authenticity of a request
            // to complete a view-change.
            vi.addMissing(m);
        }
    }

    /**
     * Execute the protocol steps associated with the arrival of a {@link CommitMessage}.
     *
     * @param m The CommitMessage.
     */
    private void handleCommit(CommitMessage m) {
        long ms = m.getSeqno();

        // Only accept messages with the current view.
        // TODO: Change to accept commits from older views as in proof.
        if (in_wv(m) && ms > low_bound) {
            Certificate<CommitMessage> cs = clog.fetch(m.getSeqno());
            if (cs.add(m) && cs.is_complete()) {
                execute_committed();
            }
        }
    }

    /**
     * Execute the protocol steps associated with the arrival of a {@link ReplyMessage}.
     *
     * @param m    The ReplyMessage.
     * @param mine True if the message is from this replica, false otherwise.
     */
    private void handleReply(ReplyMessage m, boolean mine) {
        String mid = m.id();
        long mv = m.getV();

        if (rr != null && rr.getRid() == m.getRid() && (mine || !m.is_tentative())) {
            // Only accept recovery request replies that are not tentative.
            boolean added = (mine) ? rr_reps.add_mine(m) : rr_reps.add(m);
            if (added) {
                if (rr_views.get(mid) < mv) {
                    rr_views.put(mid, mv);
                }
                if (rr_reps.is_complete()) {
                    // I have a valid reply to my outstanding recovery request.
                    // Update recovery point
                    String rep = rr_reps.cvalue().getReply();
                    // XXX: add assert len == sizeof(long)
                    long rec_seqno = Long.parseLong(rep);
                    long new_rp = rec_seqno / config.getCHECKPOINT_INTERVAL() * config.getCHECKPOINT_INTERVAL() + config.getMAX_OUT();
                    if (new_rp > recovery_point) {
                        recovery_point = new_rp;
                    }

                    // System.out.printf("XXX Complete rec reply with seqno %qd rec_point=%qd\n",rec_seqno, recovery_point);

                    // Update view number
                    long rec_view = K_max(f() + 1, rr_views, Long.MAX_VALUE);
                    enforce_view(rec_view);

                    try_end_recovery();

                    this.rr = null;
                }
            }
        }
    }

    /**
     * Returns a value "r" of "T" such that there are "k" values greater than or equal to "r" in vector.
     * It works well for small "n" and "k" and when there are many elements with the value being selected.
     * These conditions are all expected to hold.
     * Requires the vector to have "n" elements and "tmax" is the maximum value for type T
     *
     * @param k    The number of values greater than or equal to "r" in vector.
     * @param m    The collection of values.
     * @param tmax The maximum value for type T.
     * @return A value "r" of "T" such that there are "k" values greater than or equal to "r" in vector.
     */
    public long K_max(int k, Map<String, Long> m, long tmax) {
        long n = m.size();
        if (k > n) {
            return tmax;
        }

        Long last_max = tmax;
        int last_count = 0;

        long cur_max = -1;
        int cur_count = 0;

        while (last_count < k) {
            for (Map.Entry<String, Long> entry : m.entrySet()) {
                long cv = entry.getValue();
                if (cv == cur_max) {
                    cur_count++;
                    continue;
                }

                if (cv > cur_max) {
                    if (cv < last_max) {
                        cur_count = 1;
                        cur_max = cv;
                    }
                }
            }
            last_max = cur_max;
            last_count += cur_count;
            cur_max = 0;
            cur_count = 0;
        }

        return last_max;
    }

    /**
     * Execute the protocol steps associated with the arrival of a {@link ReplyMessage}.
     *
     * @param m The ReplyMessage.
     */
    private void handleReply(ReplyMessage m) {
        this.handleReply(m, false);
    }

    /**
     * Execute the protocol steps associated with the arrival of a {@link StatusMessage}.
     * TODO: Complete the implementation of this method!
     *
     * @param m The StatusMessage.
     */
    private void handleStatus(StatusMessage m) {
        if (m.verify() && this.qs == null) {
            Instant current = this.getCurrentTime();
            Instant t;
            Principal p = this.getPrincipal(m.id());

            // Retransmit messages that the sender is missing.
            if (last_stable > m.last_stable() + config.getMAX_OUT()) {
                // Node is so out-of-date that it will not accept any
                // pre-prepare/prepare/commit messages in my log.
                // Send a stable checkpoint message for my stable checkpoint.
                MessageWithTime<CheckpointMessage> myLastStableCheckpointCert = elog.fetch(last_stable).mine();
                if (myLastStableCheckpointCert.message().isEmpty() || !myLastStableCheckpointCert.message().get().stable()) {
                    throw new IllegalStateException("Invalid state!");
                }
                CheckpointMessage c = myLastStableCheckpointCert.message().get();
                this.retransmit(c, current, myLastStableCheckpointCert.time(), p);
                return;
            }

            // Retransmit any checkpoints that the sender may be missing.
            long max = Math.min(last_stable, m.last_stable()) + config.getMAX_OUT();
            long min = Math.max(last_stable, m.last_stable() + 1);
            for (long n = min; n <= max; n++) {
                if (n % this.config.getCHECKPOINT_INTERVAL() == 0) {
                    MessageWithTime<CheckpointMessage> cs = elog.fetch(n).mine();
                    if (cs.message().isPresent()) {
                        CheckpointMessage c = cs.message().get();
                        retransmit(c, current, cs.time(), p);
                        if (!(n == last_stable || !c.stable())) {
                            throw new IllegalStateException("Invalid state!");
                        }
                    }
                }
            }

            if (m.view() < v) {
                // Retransmit my latest view-change message
                MessageWithTime<ViewChangeMessage> vc = vi.my_view_change();
                if (vc.message().isPresent()) {
                    retransmit(vc.message().get(), current, vc.time(), p);
                }
                return;
            }

            if (m.view() == v) {
                if (m.has_nv_info()) {
                    min = Math.max(last_stable + 1, m.last_executed() + 1);
                    for (long n = min; n <= max; n++) {
                        if (m.is_committed(n)) {
                            // No need for retransmission of commit or pre-prepare/prepare message.
                            continue;
                        }

                        MessageWithTime<CommitMessage> c = clog.fetch(n).mine();
                        if (c.message().isPresent()) {
                            retransmit(c.message().get(), current, c.time(), p);
                        }

                        if (m.is_prepared(n)) {
                            // No need for retransmission of pre-prepare/prepare message.
                            continue;
                        }

                        // If I have a pre-prepare/prepare, send it, provide I have sent
                        // a pre-prepare/prepare for view v.
                        if (primary().equals(this.getNodeId())) {
                            MessageWithTime<PrePrepareMessage> pp = plog.fetch(n).my_pre_prepare();
                            if (pp.message().isPresent()) {
                                retransmit(pp.message().get(), current, pp.time(), p);
                            }
                        } else {
                            MessageWithTime<PrepareMessage> pr = plog.fetch(n).my_prepare();
                            if (pr.message().isPresent()) {
                                retransmit(pr.message().get(), current, pr.time(), p);
                            }
                        }
                    }

                    if (id().equals(primary())) {
                        // For now only primary retransmits big requests.
                        throw new UnsupportedOperationException("this part of handleStatus() not implemented. see from line 738-754");
                    }

                } else {
                    //m->has_nv_info() == false
                    if (!m.has_vc(this.getNodeId())) {
                        // p does not have my view-change: send it.
                        MessageWithTime<ViewChangeMessage> vc = vi.my_view_change();
                        if (vc.message().isEmpty()) {
                            throw new IllegalStateException("Invalid state!");
                        }
                        this.retransmit(vc.message().get(), current, vc.time(), p);
                    }

                    if (m.has_nv_m()) {
                        if (primary(v).equals(this.getNodeId()) && vi.hasNewView(v)) {
                            // p does not have new-view message and I am primary: send it
                            MessageWithTime<NewViewMessage> nv = vi.myNewView();
                            if (nv.message().isPresent()) {
                                this.retransmit(nv.message().get(), current, nv.time(), p);
                            }
                        } else {
                            if (primary(v).equals(this.getNodeId()) && vi.hasNewView(v)) {
                                // Send any view-change messages that p may be missing
                                // that are referred to by the new-view message. This may
                                // be important if the sender of the original message is faulty.
                                // XXXXXXXXXXXXXX
                                throw new UnsupportedOperationException("This is missing in the original code?! see line 777");
                            } else {
                                // Send any view-change acks p may be missing.
                                for (String id : this.getNodeIds()) {
                                    if (m.id().equals(id)) continue;
                                    Optional<ViewChangeAcknowledgementMessage> vca = vi.my_vc_ack(id);
                                    if (vca.isPresent() && !m.has_vc(id)) {
                                        // View-change acks are not being authenticated
                                        this.retransmit(vca.get(), current, current, p);
                                    }
                                }
                            }

                            // Send any pre-prepares that p may be missing and any proofs
                            // of authenticity for associated requests.

                            throw new UnsupportedOperationException("Not implemented this part yet! lines 792-829");
                        }
                    }
                }
            } else {
                // If is possible that we could not verify message because the
                // sender did not receive my last new_key message. It is also
                // possible message is bogus. We choose to retransmit last new_key
                // message.
                // TODO: should impose a limit on the frequency at which
                // we are willing to do it to prevent a denial of service attack.
                // This is not being done right now.
                if (last_new_key != null && (qs == null || !m.verify())) {
                    sendMessage(last_new_key, m.id());
                }
            }
        }

        throw new UnsupportedOperationException("handleStatus() not implemented");
    }

    /**
     * Execute the protocol steps associated with the arrival of a {@link ViewChangeMessage}.
     *
     * @param m The ViewChangeMessage.
     */
    private void handleViewChange(ViewChangeMessage m) {
        // System.out.printf("RECV: view change v=%qd from %s\n", m.view(), m.id());
        if (m.id().equals(primary()) && m.getViewNumber() > v) {
            if (m.verify()) {
                // "m" was sent by the primary for v and has a view number
                // higher than v: move to the next view.
                send_view_change();
            }
        }

        boolean modified = vi.add(m);
        if (!modified) {
            return;
        }

        // TODO: memoize maxv and avoid this computation if it cannot change i.e.
        // m->view() <= last maxv. This also holds for the next check.
        long maxv = vi.getMaxView();
        if (maxv > v) {
            // Replica has at least f+1 view-changes with a view number
            // greater than or equal to maxv: change to view maxv.
            this.v = maxv - 1;
            vc_recovering = true;
            send_view_change();
            return;
        }

        if (limbo && !primary().equals(this.getNodeId())) {
            maxv = vi.maxMajView();
            if (maxv > v) {
                throw new IllegalStateException("Invalid state!");
            }

            if (maxv == v) {
                // Replica now has at least 2f+1 view-change messages with view greater than
                // or equal to "v"

                // Start timer to ensure we move to another view if we do not
                // receive the new-view message for "v".
                vtimer.restart();
                limbo = false;
                vc_recovering = true;
            }
        }
    }

    /**
     * Execute the protocol steps associated with the arrival of a {@link NewViewMessage}.
     *
     * @param m The NewViewMessage.
     */
    private void handleNewView(NewViewMessage m) {
        vi.add(m);
    }

    /**
     * Execute the protocol steps associated with the arrival of a {@link CheckpointMessage}.
     *
     * @param m The CheckpointMessage.
     */
    private void handleCheckpoint(CheckpointMessage m) {
        long ms = m.getSeqno();
        if (ms > last_stable) {
            if (ms <= last_stable + this.config.getMAX_OUT()) {
                // Checkpoint is within my window. Check if checkpoint is stable and it is above
                // my last_executed. This may signal that messages I missed were garbage
                // collected and I should fetch the state.
                boolean late = m.stable() && last_executed < ms;
                if (clog.within_range(last_executed)) {
                    Instant t;
                    MessageWithTime<CommitMessage> myClogEntry = clog.fetch(last_executed).mine();
                    t = myClogEntry.time();
                    late &= diffNow(t) > 200000; // FIXME: magic numbers!
                }

                if (!late) {
                    Certificate<CheckpointMessage> cs = elog.fetch(ms);
                    if (cs.add(m) && cs.mine().message().isPresent() && cs.is_complete()) {
                        // I have enough Checkpoint messages for m->seqno() to make it stable.
                        // Truncate logs, discard older stable state versions.
                        // System.out.printf("CP MSG call MS %qd!!!\n", last_executed);
                        mark_stable(ms, true);
                    }
                    //	else {
                    //	  fprintf(stderr, "CP msg %qd not yet. Reason: ", ms);
                    //	  if (!cs.mine())
                    //	    fprintf(stderr, "does not have mine\n");
                    //	  else if (!cs.is_complete())
                    //	    fprintf(stderr, "Not complete\n");
                    //	}
                    return;
                }
            }

            if (m.verify()) {
                // Checkpoint message above my window.
                if (!m.stable()) {
                    // Send status message to obtain missing messages.
                    // This works as a negative ack.
                    send_status();
                    return;
                }

                // Stable checkpoint message above my last_executed.
                Optional<CheckpointMessage> c = sset.fetch(m.id());
                if (c.isEmpty() || c.get().seqno() < ms) {
                    sset.remove(m.id());
                    sset.store(m);
                    if (sset.size() > f()) {
                        if (last_tentative_execute > last_executed) {
                            // Rollback to last checkpoint
                            if (state.in_fetch_state()) {
                                throw new IllegalStateException("Illegal state");
                            }
                            long rc = state.rollback();
                            last_tentative_execute = last_executed = rc;
                            // System.out.printf(":):):):):):):):) Set le = %d\n", last_executed);
                        }
                        vtimer.stop();
                        state.start_fetch(last_executed);
                    }
                }
            }
        }
    }

    /**
     * Execute the protocol steps associated with the arrival of a {@link NewKeyMessage}.
     *
     * @param m The NewKeyMessage.
     */
    private void handleNewKey(NewKeyMessage m) {
        if (!m.verify()) {
            // System.out.printf("Bad NKEY from %d\n", m.id());
        }
    }

    /**
     * Execute the protocol steps associated with the arrival of a {@link ViewChangeAcknowledgementMessage}.
     *
     * @param m The ViewChangeAcknowledgementMessage.
     */
    private void handleViewChangeAck(ViewChangeAcknowledgementMessage m) {
        vi.add(m);
    }

    /**
     * Execute the protocol steps associated with the arrival of a {@link FetchMessage}.
     *
     * @param m The FetchMessage.
     */
    private void handleFetch(FetchMessage m) {
        String mid = m.getReplicaId();
        if (!state.handle(m, last_stable) && last_new_key != null) {
            this.sendMessage(last_new_key, mid);
        }
    }

    /**
     * Execute the protocol steps associated with the arrival of a {@link QueryStableMessage}.
     *
     * @param m The QueryStableMessage.
     */
    private void handleQueryStable(QueryStableMessage m) {
        if (m.verify()) {
            long lc = last_executed / config.getCHECKPOINT_INTERVAL() * config.getCHECKPOINT_INTERVAL();
            ReplyStableMessage rs = new ReplyStableMessage(this, lc, last_prepared, m.nonce(), getPrincipal(m.id()));

            // TODO: should put a bound on the rate at which I send these messages.
            this.sendMessage(rs, m.id());
        } else {
            if (last_new_key != null) {
                this.sendMessage(last_new_key, m.id());
            }
        }
    }

    /**
     * Execute the protocol steps associated with the arrival of a {@link ReplyStableMessage}.
     *
     * @param m The ReplyStableMessage.
     */
    private void handleReplyStable(ReplyStableMessage m) {
        if (qs != null && qs.nonce() == m.getNonce()) {
            if (se.add(m)) {
                // Done with estimation
                qs = null;
                recovery_point = se.estimate() + config.getMAX_OUT();

                enforce_bound(recovery_point);
                // STOP_CC(est_time)

                // System.out.printf("sending recovery request\n");
                // Send recovery request
                // START_CC(rr_time)
                RequestMessage rr = new RequestMessage(this, new_rid());

                rr.store_command(recovery_point);
                rr.sign(0); // FIXME: length?
                this.sendMessage(rr, primary());
                // STOP_CC(rr_time)

                // System.out.printf("Starting state checking\n");

                // Stop vtimer while fetching state.
                // It is restarted when the fetch ends in new_state.
                vtimer.stop();
                state.start_check(last_executed);

                // Leave multicast group
                if (true) throw new UnsupportedOperationException("leave multicast group?!");

                rqueue.clear();
                ro_rqueue.clear();
            }
        }
    }

    /**
     * Execute the protocol steps associated with the arrival of a {@link MetadataMessage}.
     *
     * @param m The MetadataMessage.
     */
    private void handleMetadata(MetadataMessage m) {
        this.state.handle(m);
    }

    /**
     * Execute the protocol steps associated with the arrival of a {@link MetadataDigestMessage}.
     *
     * @param m The MetadataDigestMessage.
     */
    private void handleMetadataD(MetadataDigestMessage m) {
        this.state.handle(m);
    }

    /**
     * Execute the protocol steps associated with the arrival of a {@link DataMessage}.
     *
     * @param m The DataMessage.
     */
    private void handleData(DataMessage m) {
        this.state.handle(m);
    }

    /**
     * Sends a prepare message if appropriate
     *
     * @param pc The prepared certificate
     */
    private void send_prepare(PreparedCertificate pc) {
        if (pc.my_prepare().message().isEmpty() && pc.is_pp_complete()) {
            // Send prepare to all replicas and log it.
            Optional<PrePrepareMessage> ppOptional = pc.pre_prepare();

            if (ppOptional.isEmpty()) {
                throw new IllegalStateException("Prepared certificate does not have a pre-prepare message");
            }

            PrePrepareMessage pp = ppOptional.get();
            PrepareMessage p = new PrepareMessage(this, v, pp.seqno(), pp.getDigest());
            // FIXME: check if also need to include self
            this.broadcastMessageIncludingSelf(p);
            pc.addMine(p);
        }
    }

    /**
     * Sends a commit message?
     *
     * @param s The sequence number?
     */
    private void send_commit(long s) {
        // Executing request before sending commit improves performance
        // for null requests. May not be true in general.
        if (s == last_executed + 1) {
            execute_prepared();
        }

        CommitMessage c = new CommitMessage(this, view(), s);
        this.broadcastMessageIncludingSelf(c);

        if (s > last_prepared) {
            last_prepared = s;
        }

        Certificate<CommitMessage> cs = clog.fetch(s);
        if (cs.add_mine(c) && cs.is_complete()) {
            execute_committed();
        }
    }

    /**
     * Send a pre-prepare with a null request if the system is idle
     */
    private void send_null() {
        if (!primary().equals(id())) {
            throw new IllegalStateException("Non-primary called send_null");
        }

        long max_rec_point = config.getMAX_OUT() + (max_rec_n + config.getCHECKPOINT_INTERVAL() - 1) / config.getCHECKPOINT_INTERVAL() * config.getCHECKPOINT_INTERVAL();

        if (max_rec_n != 0 && max_rec_point > last_stable && has_new_view()) {
            if (rqueue.size() == 0 && seqno <= last_executed && seqno + 1 <= config.getMAX_OUT() + last_stable) {
                seqno++;
                ReqQueue empty = new ReqQueue(this);
                PrePrepareMessage pp = new PrePrepareMessage(view(), seqno, empty);
                this.broadcastMessageIncludingSelf(pp);
                plog.fetch(seqno).add_mine(pp);
            }
        }
        ntimer.restart();

        // TODO: backups should force view change if primary does not send null requests
        // to allow recoveries ot complete

    }

    /**
     * If some request that was tentatively executed did not commit yet
     * (i.e. last_tentative_execute < last_executed), returns false.
     * Otherwise, returns true, executes the comand in request "m" (provided
     * it is really read-only and does not require non-deterministic choices),
     * and sends a reply to the client.
     *
     * @param m The request message
     * @return True if the request was executed, false otherwise
     */
    private boolean execute_read_only(RequestMessage m) {
        throw new UnsupportedOperationException("execute_read_only() not implemented");
    }

    /**
     * Executes as many commands as possible by calling execute_prepared; sends
     * Checkpoint messages when needed and manipulates the wait timer.
     */
    private void execute_committed() {
        throw new UnsupportedOperationException("execute_committed() not implemented");
    }

    /**
     * Tentatively executes as many commands as possible. It extracts requests to execute
     * commands from a message "m"; calls exec_command for each command; and sends back
     * replies to the client. The replies are tentative unless "committed" is true
     *
     * @param committed True if replies are committed, tentative otherwise
     */
    private void execute_prepared(boolean committed) {
        throw new UnsupportedOperationException("execute_prepared() not implemented");
    }

    /**
     * Tentatively executes as many commands as possible. It extracts requests to execute
     * commands from a message "m"; calls exec_command for each command; and sends back
     * replies to the client. The replies are tentative.
     */
    private void execute_prepared() {
        execute_prepared(false);
    }

    /**
     * Marks it as stable and garbage collects information.
     * Requires checkpoint with sequence number "seqno" to be stable.
     *
     * @param seqno      The sequence number of the checkpoint
     * @param have_state should be true iff the replica has a the stable checkpoint
     */
    private void mark_stable(long seqno, boolean have_state) {
        throw new UnsupportedOperationException("mark_stable() not implemented");
    }

    /**
     * Updates this to reflect that the checkpoint with sequence number "seqno" was fetch.
     *
     * @param seqno The sequence number of the checkpoint
     */
    private void new_state(long seqno) {
        throw new UnsupportedOperationException("new_state() not implemented");
    }

    /**
     * Recover replica
     */
    private void recover() {
        throw new UnsupportedOperationException("recover() not implemented");
    }

    /**
     * Returns non-zero iff there is a pre-prepare pp that prepared for
     * sequence number "s" (in this case it returns pp)
     *
     * @param s The sequence number
     * @return The pre-prepare message
     */
    private Optional<PrePrepareMessage> prepared(long s) {
        throw new UnsupportedOperationException("prepared() not implemented");
    }

    /**
     * Returns non-zero iff there is a pre-prepare pp that committed for
     * sequence number "s" (in this case it returns pp)
     *
     * @param s The sequence number
     * @return The pre-prepare message
     */
    private Optional<PrePrepareMessage> committed(long s) {
        throw new UnsupportedOperationException("committed() not implemented");
    }

    /**
     * Check if replica has complete new-view information for current view
     *
     * @return true if replica has complete new-view information for current view, false otherwise
     */
    private boolean has_new_view() {
        throw new UnsupportedOperationException("has_new_view() not implemented");
    }

    /**
     * Returns true iff the message "m" has a sequence number greater than last_stable
     * and less than or equal to last_stable + max_out
     *
     * @param m The message to check
     * @return True if the message has a sequence number greater than last_stable and less than or equal to last_stable + max_out
     */
    private boolean in_w(PbftMessagePayloadWithSequenceNumber m) {
        long offset = m.seqno() - last_stable;

        if (offset > 0 && offset <= config.getMAX_OUT()) {
            return true;
        }

        if (offset > config.getMAX_OUT() && m.verify()) {
            // Send status message to obtain missing messages.
            // This works as a negative ack.
            send_status();
        }

        return false;
    }

    /**
     * Check iff "in_w(m)" and "m" has the current view.
     *
     * @param m The message to check
     * @return True if in_w(m) and m has the current view, false otherwise
     */
    private boolean in_wv(PbftMessagePayloadWithSequenceNumber m) {
        long offset = m.seqno() - last_stable;

        if (offset > 0 && offset <= config.getMAX_OUT() && m.view() == view()) {
            return true;
        }

        if ((m.view() > view() || offset > config.getMAX_OUT()) && m.verify()) {
            // Send status message to obtain missing messages.
            // This works as a negative ack.
            send_status();
        }

        return false;
    }

    /**
     * Handles generic messages
     *
     * @param m The message to handle
     */
    private void gen_handle(MessagePayload m) {
        // XXX: do we need this?! We already have ByzzBench's handleMessage()!
        throw new UnsupportedOperationException("gen_handle() not implemented");
    }

    /**
     * Retransmits message m (and re-authenticates it) if needed.
     *
     * @param m     The message to retransmit
     * @param cur   current time
     * @param tsent time at which the message was sent?
     * @param p     The principal?
     */
    private void retransmit(MessagePayload m, Instant cur, Instant tsent, Principal p) {
        // FIXME: Time types are not yet implemented!
        throw new UnsupportedOperationException("retransmit() not implemented");
    }

    /**
     * Retransmits Reply message m (and re-authenticates it) if needed?
     *
     * @param m     The message to retransmit
     * @param cur   current time
     * @param tsent time at which the message was sent?
     * @param p     The principal?
     * @return true if the message was retransmitted, false otherwise?
     */
    private boolean retransmit_rep(ReplyMessage m, Instant cur, Instant tsent, Principal p) {
        throw new UnsupportedOperationException("retransmit_rep() not implemented");
    }

    /**
     * Calls the Node's send_new_key, adjusts timer and cleans up stale messages.
     */
    private void send_new_key() {
        /* From Node.cc */
        // Multicast new key to all replicas
        last_new_key = new NewKeyMessage(this);
        this.broadcastMessageIncludingSelf(last_new_key);

        // Stop timer if not expired and then restart it
        atimer.stop();
        atimer.restart();

        /* From Replica.cc */
        // Cleanup messages in incomplete certificates that are authenticated with the old keys
        long max = last_stable + config.getMAX_OUT();
        long min = last_stable + 1;
        for (long n = min; n < max; n++) {
            if (n % config.getCHECKPOINT_INTERVAL() == 0) {
                elog.fetch(n).mark_stale();
            }
        }

        if (last_executed > last_stable) {
            min = last_executed + 1;
        }

        for (long n = min; n <= max; n++) {
            plog.fetch(n).mark_stale();
            clog.fetch(n).mark_stale();
        }

        vi.markStale();
        state.mark_stale();

        throw new UnsupportedOperationException("send_new_key() not implemented");
    }

    /**
     * Ensures that there is no information above bound "b".
     *
     * @param b The bound
     */
    private void enforce_bound(long b) {
        if (!(recovering && se.estimate() >= 0)) {
            throw new IllegalStateException("Invalid state");
        }

        boolean correct = !corrupt && last_stable <= b - config.getMAX_OUT()
                && seqno <= b && low_bound <= b && last_prepared <= b
                && last_tentative_execute <= b && last_executed <= b
                && (last_tentative_execute == last_executed || last_tentative_execute == last_executed + 1);

        for (long i = b + 1; correct && (i <= plog.max_seqno()); i++) {
            if (!plog.fetch(i).is_empty()) {
                correct = false;
            }
        }

        for (long i = b + 1; correct && (i <= clog.max_seqno()); i++) {
            if (!clog.fetch(i).is_empty()) {
                correct = false;
            }
        }

        for (long i = b + 1; correct && (i <= elog.max_seqno()); i++) {
            if (!elog.fetch(i).is_empty()) {
                correct = false;
            }
        }

        long known_stable = se.low_estimate();
        if (!correct) {
            System.out.printf("Incorrect state setting low bound to %d%n", known_stable);
            seqno = last_prepared = low_bound = last_stable = known_stable;
            last_tentative_execute = last_executed = 0;
            limbo = false;
            plog.clear(known_stable + 1);
            clog.clear(known_stable + 1);
            elog.clear(known_stable);
        }

        correct &= vi.enforceBound(b, known_stable, !correct);
        correct &= state.enforce_bound(b, known_stable, !correct);
        corrupt = !correct;
    }

    /**
     * If replica is corrupt, sets its view to rec_view and ensures there is no
     * information for a later view in its.
     *
     * @param rec_view The view number
     */
    private void enforce_view(long rec_view) {
        if (!recovering) {
            throw new IllegalStateException("Invalid state");
        }

        if (rec_view >= v || vc_recovering || (limbo && rec_view + 1 == v)) {
            // Replica's view number is reasonable; do nothing
            return;
        }

        corrupt = true;
        vi.clear();
        v = rec_view - 1;
        send_view_change();
    }

    /**
     * If max_rec_n is different from the maximum sequence number for a recovery request in
     * the state, updates it to have that value and changes keys. Otherwise, does nothing.
     */
    private void update_max_rec() {
        throw new UnsupportedOperationException("update_max_rec() not implemented");
    }

    /**
     * Pointer to the beggining of the mem region used to store the replies
     *
     * @return The pointer to the beginning of the memory region
     */
    private String rep_info_mem() {
        if (config.NO_STATE_TRANSLATION()) {
            throw new AssertionError("Only available in BASE");
        }
        throw new UnsupportedOperationException("rep_info_mem() not implemented");
    }

    /**
     * Enables receipt of messages sent to replica group
     */
    private void join_mcast_group() {
        // FIXME: Not implemented (lack of support on the framework)
        log.log(Level.SEVERE, "join_mcast_group() not implemented");
    }

    /**
     * Disables receipt of messages sent to replica group
     */
    private void leave_mcast_group() {
        // FIXME: Not implemented (lack of support on the framework)
        log.log(Level.SEVERE, "leave_mcast_group() not implemented");
    }

    /**
     * Ends recovery if all the conditions are satisfied
     */
    private void try_end_recovery() {
        if (recovering && last_stable >= recovery_point && !state.in_check_state() && rr_reps.is_complete()) {
            // Done with recovery.
            // END_REC_STATS();
            // TODO: join_mcast_group()
            recovering = false;

            // Execute any buffered read-only requests
            for (Optional<RequestMessage> m = ro_rqueue.remove(); m.isPresent(); m = ro_rqueue.remove()) {
                execute_read_only(m.get());
            }
        }

        throw new UnsupportedOperationException("try_end_recovery() not implemented");
    }

    /**
     * Returns the current view number.
     *
     * @return The current view number.
     */
    public long view() {
        return v;
    }

    /**
     * Returns the number of replicas in the system.
     *
     * @return The number of replicas in the system.
     */
    public int n() {
        return this.getNodeIds().size();
    }

    /**
     * Returns the maximum number of faulty replicas in the system.
     *
     * @return The maximum number of faulty replicas in the system.
     */
    public int f() {
        return (this.getNodeIds().size() - 1) / 3;
    }

    /**
     * Returns the number of correct replicas.
     *
     * @return The number of correct replicas.
     */
    public int n_f() {
        return n() - f();
    }

    /**
     * Returns the number of principals
     *
     * @return The number of principals
     */
    public int np() {
        return this.principals.size();
    }

    /**
     * If "i" is an invalid principal identifier, returns false and does nothing.
     * Otherwise, returns true iff "dest" contains an authenticator by principal "i"
     * that is valid for the calling principal (i.e. computed with calling principal's
     * in-key if in is true and out-keys otherwise).
     * <p>
     * Requires that "i" is not the calling principal and same as gen_auth.
     *
     * @param i The principal identifier.
     * @return True iff the authenticator is valid for the calling principal.
     */
    private boolean verify_auth(String i, String src, boolean in) {
        throw new UnsupportedOperationException("verify_auth() not implemented");
    }

    /**
     * Unique identifier generation:
     * Computes a new request identifier. The new request identifier is guaranteed
     * to be larger than any request identifier produced by the node in the past
     * (even across) reboots (assuming clock as returned by gettimeofday retains
     * value after a crash.).
     *
     * @return A new request identifier.
     */
    public long new_rid() {
        if (cur_rid == Long.MAX_VALUE) {
            new_tstamp();
        }
        return ++cur_rid;
    }

    /**
     * Computes a new timestamp for rid
     */
    public void new_tstamp() {
        Instant t = getCurrentTime();
        cur_rid = t.toEpochMilli();
    }

    /**
     * Returns the unique identifier of this replica.
     *
     * @return The identifier of this replica.
     */
    public String id() {
        return this.getNodeId();
    }

    /**
     * Computes non-deterministic choices for sequence number "n"
     *
     * @param n The sequence number.
     */
    public void compute_non_det(long n) {
        throw new UnsupportedOperationException("compute_non_det() not implemented");
    }

    /**
     * Computes non-deterministic choices for sequence number "n", places them in the array
     * pointed to by "b" and returns their size.
     *
     * @param n The sequence number
     * @param b The array to place the choices in
     * @return The size of the choices
     */
    public long compute_non_det(long n, String b) {
        if (non_det_choices == null) {
            return 0;
        }
        throw new UnsupportedOperationException("compute_non_det() not finished being implemented");
    }

    /**
     * Maximum length of the choices computed by compute_non_det
     *
     * @return The maximum length of the choices computed by compute_non_det
     */
    public long max_nd_bytes() {
        throw new UnsupportedOperationException("max_nd_bytes() not implemented");
    }

    /**
     * Returns the number of bytes used up to store protocol information
     *
     * @return The number of bytes used up to store protocol information
     */
    public long used_state_bytes() {
        throw new UnsupportedOperationException("used_state_bytes() not implemented");
    }

    /**
     * Returns the number of pages used up to store protocol information
     *
     * @return The number of pages used up to store protocol information
     */
    public long used_state_pages() {
        if (config.NO_STATE_TRANSLATION()) {
            throw new AssertionError("Only available in BASE");
        }

        throw new UnsupportedOperationException("used_state_pages() not implemented");
    }

    /**
     * Informs the system that the memory region is about to be modified
     *
     * @param mem The memory region
     */
    public void modify(String mem) {
        if (!config.NO_STATE_TRANSLATION()) {
            throw new AssertionError("Only available in BFT");
        }
        throw new UnsupportedOperationException("modify() not implemented");
    }

    /**
     * Informs the system that the replies page with index "bindex" is about to be modified
     *
     * @param bindex The index of the replies page
     */
    public void modify_index_replies(int bindex) {
        if (config.NO_STATE_TRANSLATION()) {
            throw new AssertionError("Only available in BASE");
        }
        throw new UnsupportedOperationException("modify_index_replies() not implemented");
    }

    /**
     * Informs the system that the memory page with index "bindex" is about to be modified
     *
     * @param bindex The index of the memory page
     */
    public void modify_index(int bindex) {
        throw new UnsupportedOperationException("modify_index() not implemented");
    }

    /**
     * Update replica's state to reflect a new-view
     *
     * @param min sequence number of the checkpoint propagated by new-view message
     * @param d   digest of the checkpoint propagated by new-view message
     * @param max maximum sequence number of a propagated request +1
     * @param ms  maximum sequence number known to be stable
     */
    public void process_new_view(long min, Digest d, long max, long ms) {
        throw new UnsupportedOperationException("process_new_view() not implemented");
    }

    /**
     * Get the ID of the primary for a given view
     *
     * @param v the view number
     * @return the ID of the primary for the given view
     */
    public String getPrimaryForView(long v) {
        return this.getNodeIds().stream().toList().get((int) (v % this.getNodeIds().size()));
    }

    /**
     * Get the ID of the primary for the current view (v)
     *
     * @return the ID of the primary for the current view
     */
    public String getPrimaryForView() {
        return getPrimaryForView(v);
    }

    /**
     * Send view-change message
     */
    public void send_view_change() {
        // Move to next view
        v++;
        cur_primary = getPrimaryForView(v);
        limbo = true;
        vtimer.stop(); // stop timer if it is still running
        ntimer.restop();

        if (last_tentative_execute > last_executed) {
            // Rollback to last checkpoint
            if (state.in_fetch_state()) {
                throw new IllegalStateException("Invalid state");
            }
            long rc = state.rollback();
            // System.out.println("XXXRolled back in vc to %qd with last_executed=%qd\n", rc, last_executed);
            last_tentative_execute = last_executed = rc;
            // System.out.printf(":):):):):):):):) Set le = %d\n", last_executed);
        }

        last_prepared = last_executed;

        for (long i = last_stable + 1; i < last_stable + config.getMAX_OUT(); i++) {
            PreparedCertificate pc = plog.fetch(i);
            Certificate<CommitMessage> cc = clog.fetch(i);

            if (pc.is_complete()) {
                vi.addComplete(pc.rem_pre_prepare());
            } else {
                MessageWithTime<PrepareMessage> p = pc.my_prepare();
                if (p.message().isPresent()) {
                    vi.addIncomplete(i, p.message().get().digest());
                } else {
                    MessageWithTime<PrePrepareMessage> pp = pc.my_pre_prepare();
                    if (pp.message().isPresent()) {
                        vi.addIncomplete(i, pp.message().get().getDigest());
                    }
                }
            }

            pc.clear();
            cc.clear();
            // TODO: Could remember info about committed requests for efficiency.
        }

        // Create and send view-change message.
        System.out.printf("XXX SND: view change %d%n", v);
        vi.viewChange(v, last_executed, state);
    }

    /**
     * Sends a status message
     */
    public void send_status() {
        Instant cur = getCurrentTime();
        if (Duration.between(cur, last_status).toMillis() < 100) {
            // Only send new status message if last one was sent more than 100 milliseconds ago
            last_status = cur;

            if (qs != null) {
                // Retransmit query stable if I am estimating last stable
                qs.re_authenticate();
                this.broadcastMessageIncludingSelf(qs);
                return;
            }

            if (rr != null) {
                // Retransmit recovery request if I am waiting for one.
                this.broadcastMessageIncludingSelf(rr);
            }

            // If fetching state, resend last fetch message instead of status.
            if (state.retrans_fetch(cur)) {
                state.send_fetch(true);
                return;
            }

            StatusMessage s = new StatusMessage(this, v, last_stable, last_executed, has_new_view(), vi.hasNvMessage(v));

            if (has_new_view()) {
                // Set prepared and committed bitmaps correctly
                long max = last_stable + config.getMAX_OUT();
                for (long n = last_executed + 1; n <= max; n++) {
                    PreparedCertificate pc = plog.fetch(n);
                    if (pc.is_complete() || state.in_check_state()) { // XXXX added state.in_check_state()
                        s.mark_prepared(n);
                        if (clog.fetch(n).is_complete() || state.in_check_state()) {
                            s.mark_committed(n);
                        }
                    } else {
                        // Ask for missing big requests
                        if (!pc.is_pp_complete() && pc.pre_prepare().isPresent() && pc.num_correct() >= f()) {
                            s.add_breqs(n, pc.missing_reqs());
                        }
                    }
                }
            } else {
                vi.setReceivedVcs(s);
                vi.setMissingPps(s);
            }

            // Multicast status to all replicas.
            s.authenticate();
            this.broadcastMessageIncludingSelf(s);
        }
    }

    /**
     * Shuts down replica writing a checkpoint to disk
     *
     * @return true if the shutdown was successful
     */
    public boolean shutdown() {
        throw new UnsupportedOperationException("shutdown() not implemented");
    }

    /**
     * Restarts the replica from the checkpoint in i
     *
     * @return true if the restart was successful
     */
    public boolean restart(String i) {
        throw new UnsupportedOperationException("restart() not implemented");
    }

    /**
     * Check if there is a request from client buffered with operation digest.
     * XXX not great
     *
     * @param cid the client identifier
     * @param d   the digest of the request
     * @return true if there is a request from client buffered with operation digest
     */
    public boolean has_req(int cid, Digest d) {
        throw new UnsupportedOperationException("has_req() not implemented");
    }

    /**
     * Check if view change should be delayed
     *
     * @return true if view change should be delayed, false otherwise
     */
    public boolean delay_vc() {
        throw new UnsupportedOperationException("delay_vc() not implemented");
    }

    /**
     * Returns the replica's big request table.
     *
     * @return The replica's big request table.
     */
    public BigReqTable big_reqs() {
        throw new UnsupportedOperationException("big_reqs() not implemented");
    }

    /**
     * Get cached object
     *
     * @param i the index of the object??
     * @return the cached object
     */
    public String get_cached_obj(int i) {
        if (config.NO_STATE_TRANSLATION()) {
            throw new AssertionError("Only available in BASE");
        }

        throw new UnsupportedOperationException("get_cached_obj() not implemented");
    }

    /**
     * Registers "e" as the exec_command function
     *
     * @param r The exec_command function
     */
    public void register_exec(Runnable r) {
        throw new UnsupportedOperationException("register_exec() not implemented");
    }

    /**
     * Registers "n" as the non_det_choices function and "check" as the check_non_det check function
     *
     * @param n       The non_det_choices function
     * @param max_len The maximum length of the choices
     * @param check   The check_non_det check function
     */
    public void register_nondet_choices(Runnable n, int max_len, Function<ByzBuffer, Boolean> check) {
        if (this.config.NO_STATE_TRANSLATION()) {
            throw new AssertionError("Only available in BASE");
        }

        this.check_non_det = check;
        this.non_det_choices = n;
        this.max_nondet_choice_len = max_len;
    }

    /**
     * Registers "n" as the non_det_choices function and "check" as the check_non_det check function
     *
     * @param n       The non_det_choices function
     * @param max_len The maximum length of the choices
     */
    public void register_nondet_choices(Runnable n, int max_len) {
        if (!this.config.NO_STATE_TRANSLATION()) {
            throw new AssertionError("Only available in BFT");
        }

        this.non_det_choices = n;
        this.max_nondet_choice_len = max_len;
    }


}
