package byzzbench.simulator.domain;

import byzzbench.simulator.Scenario;
import byzzbench.simulator.ScenarioPredicate;
import byzzbench.simulator.transport.Event;
import byzzbench.simulator.transport.MessageEvent;
import byzzbench.simulator.transport.MutateMessageEvent;
import byzzbench.simulator.transport.TimeoutEvent;
import byzzbench.simulator.utils.NonNull;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;
import java.util.*;

/**
 * Represents a schedule of events that can be executed by the simulator.
 */
@JsonIgnoreProperties(ignoreUnknown = true)
@Entity
@NoArgsConstructor
@Data
public class Schedule implements Serializable {
    /**
     * The unique identifier of the schedule.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long scheduleId;

    /**
     * The list of actions in the schedule
     */
    @NonNull
    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.EAGER, mappedBy = "schedule")
    private List<Action> actions = new ArrayList<>();

    @ManyToOne
    @JsonIgnore
    private Campaign campaign;

    /**
     * The set of invariants that are violated by this schedule.
     */
    @NonNull
    @Transient
    private SortedSet<ScenarioPredicate> brokenInvariants = new TreeSet<>();

    /**
     * The scenario generated by this schedule.
     */
    @NonNull
    @JsonIgnore
    @Transient
    private Scenario scenario;

    /**
     * Whether the schedule is finalized or not.
     */
    @NonNull
    private boolean isFinalized = false;

    /**
     * Creates a new schedule for the given scenario.
     *
     * @param scenario the scenario that generated this schedule.
     */
    public Schedule(Scenario scenario) {
        this.scenario = scenario;
    }

    public void appendEvent(Event event) {
        if (isFinalized) {
            throw new IllegalStateException("Cannot append event to a schedule with broken invariants");
        }

        switch (event) {
            case MessageEvent messageEvent -> appendAction(DeliverMessageAction.builder()
                    .recipientId(messageEvent.getRecipientId())
                    .senderId(messageEvent.getSenderId())
                    .timestamp(messageEvent.getCreatedAt())
                    .payload(messageEvent.getPayload())
                    .schedule(this)
                    .build());
            case MutateMessageEvent mutateMessageEvent -> appendAction(FaultInjectionAction.builder()
                    .faultId("mutate-" + mutateMessageEvent.getEventId())
                    .payload(mutateMessageEvent.getPayload())
                    .schedule(this)
                    .build());
            case TimeoutEvent timeoutEvent -> appendAction(TriggerTimeoutAction.builder()
                    .eventId(timeoutEvent.getEventId())
                    .timeout(timeoutEvent.getTimeout())
                    .schedule(this)
                    .build());
            default -> throw new IllegalArgumentException("Unsupported event type: " + event.getClass().getName());
        }
    }

    /**
     * Appends the given action to the schedule.
     *
     * @param action the action to append.
     */
    public void appendAction(Action action) {
        if (isFinalized) {
            throw new IllegalStateException("Cannot append action to a schedule with broken invariants");
        }
        actions.add(action);
    }

    /**
     * Marks the schedule as read-only, with the given broken invariants.
     *
     * @param brokenInvariants the set of broken invariants.
     */
    public void finalizeSchedule(Set<ScenarioPredicate> brokenInvariants) {
        isFinalized = true;
        this.brokenInvariants.addAll(brokenInvariants);
    }

    /**
     * Marks the schedule as read-only, without any broken invariants.
     */
    public void finalizeSchedule() {
        finalizeSchedule(Collections.emptySet());
    }

    /**
     * Returns true if the schedule is buggy, i.e., it violates some invariants.
     *
     * @return true if the schedule is buggy, false otherwise.
     */
    @JsonIgnore
    public boolean isBuggy() {
        return !brokenInvariants.isEmpty();
    }

    /**
     * Returns the id of the scenario that generated this schedule.
     *
     * @return the id of the scenario that generated this schedule.
     */
    public @NonNull Scenario getScenario() {
        if (scenario == null) {
            // FIXME: should generate a scenario materializing the schedule here!
            throw new IllegalStateException("No scenario set for this schedule");
        }
        return this.scenario;
    }
}
