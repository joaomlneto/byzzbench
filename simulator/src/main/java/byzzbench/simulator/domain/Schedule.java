package byzzbench.simulator.domain;

import byzzbench.simulator.Scenario;
import byzzbench.simulator.ScenarioPredicate;
import byzzbench.simulator.service.ApplicationContextProvider;
import byzzbench.simulator.service.ScenarioService;
import byzzbench.simulator.transport.Event;
import byzzbench.simulator.transport.MessageEvent;
import byzzbench.simulator.transport.MutateMessageEvent;
import byzzbench.simulator.transport.TimeoutEvent;
import byzzbench.simulator.utils.NonNull;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import io.hypersistence.utils.hibernate.type.json.JsonType;
import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.Type;

import java.io.Serializable;
import java.util.*;

/**
 * Represents a schedule of events that can be executed by the simulator.
 */
@JsonIgnoreProperties(ignoreUnknown = true)
@Entity
@NoArgsConstructor
@Data
public class Schedule implements Serializable {
    /**
     * The unique identifier of the schedule.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long scheduleId;

    /**
     * A human-readable name/description for the schedule.
     */
    private String name;

    /**
     * The initial parameters of the scenario that generated this schedule.
     */
    @Type(JsonType.class)
    @Column(columnDefinition = "json")
    private ScenarioParameters parameters;

    /**
     * The list of actions in the schedule
     */
    @NonNull
    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.EAGER, mappedBy = "schedule")
    private List<Action> actions = new ArrayList<>();

    @ManyToOne
    @JsonIgnore
    private Campaign campaign;

    /**
     * The set of invariants that are violated by this schedule.
     */
    @NonNull
    @Transient
    private SortedSet<ScenarioPredicate> brokenInvariants = new TreeSet<>();

    /**
     * The scenario generated by this schedule (may be null if not generated).
     */
    @JsonIgnore
    @Transient
    private transient Optional<Scenario> scenario = Optional.empty();

    /**
     * Creates a new schedule for the given scenario.
     *
     * @param parameters the initial parameters of the scenario that generated this schedule.
     */
    public Schedule(ScenarioParameters parameters) {
        this.parameters = parameters;
    }

    public void appendEvent(Event event) {
        switch (event) {
            case MessageEvent messageEvent -> appendAction(DeliverMessageAction.builder()
                    .messageEventId(event.getEventId())
                    .recipientId(messageEvent.getRecipientId())
                    .senderId(messageEvent.getSenderId())
                    .timestamp(messageEvent.getCreatedAt())
                    .payload(messageEvent.getPayload())
                    .schedule(this)
                    .build());
            case MutateMessageEvent mutateMessageEvent -> appendAction(FaultInjectionAction.builder()
                    .faultId("mutate-" + mutateMessageEvent.getEventId())
                    .payload(mutateMessageEvent.getPayload())
                    .schedule(this)
                    .build());
            case TimeoutEvent timeoutEvent -> appendAction(TriggerTimeoutAction.builder()
                    .timeoutEventId(timeoutEvent.getEventId())
                    .timeout(timeoutEvent.getTimeout())
                    .schedule(this)
                    .build());
            default -> throw new IllegalArgumentException("Unsupported event type: " + event.getClass().getName());
        }
    }

    /**
     * Appends the given action to the schedule.
     *
     * @param action the action to append.
     */
    public void appendAction(Action action) {
        actions.add(action);
    }

    /**
     * Marks the schedule as read-only, with the given broken invariants.
     *
     * @param brokenInvariants the set of broken invariants.
     */
    public void finalizeSchedule(Set<ScenarioPredicate> brokenInvariants) {
        this.brokenInvariants.addAll(brokenInvariants);
    }

    /**
     * Marks the schedule as read-only, without any broken invariants.
     */
    public void finalizeSchedule() {
        finalizeSchedule(Collections.emptySet());
    }

    /**
     * Returns true if the schedule is buggy, i.e., it violates some invariants.
     *
     * @return true if the schedule is buggy, false otherwise.
     */
    @JsonIgnore
    public boolean isBuggy() {
        return !brokenInvariants.isEmpty();
    }

    /**
     * Returns the id of the scenario that generated this schedule.
     *
     * @return the id of the scenario that generated this schedule.
     */
    public @NonNull Scenario getScenario() {
        return this.scenario.orElseThrow(() -> new IllegalStateException("No scenario set for this schedule"));
    }

    /**
     * Returns the length of the schedule, i.e., the number of actions in it.
     *
     * @return the length of the schedule.
     */
    public int getLength() {
        return this.actions.size();
    }

    /**
     * Materializes the scenario associated with this schedule, if not already done.
     * This method will throw an exception if the schedule already has a scenario.
     *
     * @return the materialized scenario.
     * @throws IllegalStateException if the schedule already has a scenario.
     */
    public Scenario materializeScenario() {
        System.out.println("Materializing scenario for schedule " + this.scheduleId);

        // check if already materialized
        if (this.isMaterialized()) {
            System.out.println("Schedule " + this.scheduleId + " already has a scenario associated with it");
            System.out.println("Scenario: " + this.scenario);
            throw new IllegalStateException("Schedule already has a scenario associated with it");
        }

        System.out.println("\n\n\n\n\nMaterializing scenario for schedule " + this.scheduleId);

        String scenarioFactoryId = this.parameters.getScenarioFactoryId();
        System.out.println("Using scenario factory: " + scenarioFactoryId);

        ScenarioService scenarioService = ApplicationContextProvider.getScenarioService();
        long scenarioId = scenarioService.generateScenario(this);
        System.out.println("Generated scenario with ID: " + scenarioId);

        Scenario scenario = scenarioService.getScenarios().get(scenarioId);
        scenario.setScenarioId(scenarioId);
        this.scenario = Optional.of(scenario);

        // apply each action in order
        for (Action action : this.actions) {
            action.accept(scenario);
        }

        System.out.println("Done materializing scenario for schedule " + this.scheduleId + "\n\n\n");
        return scenario;
    }

    public boolean isMaterialized() {
        return this.scenario.isPresent();
    }

    /**
     * Method executed after the entity is loaded into the persistence context.
     * This method attempts to initialize the `scenario` field by fetching the
     * corresponding scenario from the ScenarioService using the schedule ID.
     * If no scenario is found for the given schedule ID, the `scenario` field
     * remains unset.
     */
    @PostLoad
    public void onLoad() {
        try {
            this.scenario = Optional.of(ApplicationContextProvider.getScenarioService().getScenarioById(this.getScheduleId()));
            System.out.println("Found scenario for schedule " + this.scheduleId);
        } catch (NoSuchElementException e) {
            System.out.println("No scenario found for schedule " + this.scheduleId);
            // ignore - scenario not materialized
        }
    }
}
